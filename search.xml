<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[hexo -d报错解决办法]]></title>
      <url>%2Fblog%2F2017%2F03%2F04%2Fhexo-d%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[hexo d的时候报错，错误信息如下：12345678$ hexo dINFO Deploying: gitINFO Clearing .deploy folder...INFO Copying files from public folder...warning: LF will be replaced by CRLF in 2015/12/05/hello-world/index.html.The file will have its original line endings in your working directory.……warning: LF will be replaced by CRLF in index.html. 在某乎上找到了答案，链接在文章最下面。 搬运工来啦： 这个问题是这样解决的 删除你hexo 下面的.deploy_git文件夹 运行 1git config -global core.autoclrf false 重新部署123hexo cleanhexo ghexo d 打开自己的网址，进行验证是否成功 作者：邹世杰链接：https://www.zhihu.com/question/38219432/answer/123443945来源：知乎 written by MARSGGBO2017-2-14]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongoDB学习笔记]]></title>
      <url>%2Fblog%2F2017%2F03%2F04%2FmongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[一、数据库的基本概念及操作|SQL术语/概念| MongoDB术语/概念| 解释/说明||——|——-|——–||database| database| 数据库||table| collection| 数据库表/集合||row| document| 数据记录行/文档||column| field| 数据字段/域||index| index| 索引||table| joins| 表连接,MongoDB不支持||primary key| primary key| 主键,MongoDB自动将_id字段设置为主键| 创建数据库 1&gt; use mydb 查看当前连接的数据库 123&gt; db-&gt; mydb 查看所有的数据库 123&gt; show dbs-&gt; mydb 销毁数据库 123&gt; use local switched to db local&gt; db.dropDatabase() 二、集合(Collection)的基本操作 创建集合 1&gt; db.creationCollection('users') 查看创建的集合 1&gt; show collections 删除集合 1&gt; db.users.drop() 向集合中插入数据 1.==insert()==插入数据时，如果 users 集合没有创建会自动创建。12345678910&gt; use mydbswitched to db mydb&gt; db.users.insert([... &#123; name : "jam",... email : "jam@qq.com"... &#125;,... &#123; name : "tom",... email : "tom@qq.com"... &#125;... ]) 2.==使用 save()==插入数据时，如果 users 集合没有创建会自动创建。12345678910&gt; use mydb2switched to db mydb2&gt; db.users.save([... &#123; name : "jam",... email : "jam@qq.com"... &#125;,... &#123; name : "tom",... email : "tom@qq.com"... &#125;... ]) 更新数据db.COLLECTION_NAME.update(SELECTION_CRITERIA,UPDATED_DATA) 123&gt; use mydb2switched to db mydb2&gt; db.mysb2.update(&#123;'name':'jam'&#125;,&#123;'name':'bob'&#125;) 删除数据db.COLLECTION_NAME.remove(DELECTION_CRITERIA) 123&gt; use mydb2switched to db mydb2&gt; db.mydb2.remove(&#123;'name':'tom'&#125;) 操作语句 作用 db.createCollection(‘COLLECTION_NAME’) 创建集合 db.COLLECTION.drop() 删除集合 db.COLLECTION_NAME.insert(document) 插入文档 db.COLLECTION_NAME.update(SELECTION_CRITERIA,UPDATED_DATA) 更新文档 db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA}) 替换已存在的文档 db.COLLECTION_NAME.remove(DELECTION_CRITERIA) 删除文档 三、数据查询 find() 语句123&gt; use mydbswitched to db mydb&gt; db.mydb.insert(&#123;'name':'mars','age':12,'gender':'man'&#125;) 1.不加参数时返回所有记录123&gt; db.mydb.find()&#123; "_id" : ObjectId("589dc5f3e86d38da8455b314"), "name" : "marsggbo" &#125;&#123; "_id" : ObjectId("589dcac5e86d38da8455b315"), "name" : "mars", "age" : 12, "gender" : "man" &#125; 2.带参数123&gt; use mydb&gt; db.mydb.find(&#123;'name':'mars'&#125;)&#123; "_id" : ObjectId("589dcac5e86d38da8455b315"), "name" : "mars", "age" : 12, "gender" : "man" &#125; 2.1 条件操作符1 (&gt;) 大于 - \$gt #greate(&lt;) 小于 - \$lt #low(&gt;=) 大于等于 - \$gte #equal(&lt;= ) 小于等于 - \$lte 2.2 条件操作符2 type1$type type的值： 双精度型-1字符串-2对象-3数组-4二进制数据-5对象ID-7布尔类型-8数据-9空-10正则表达式-11JS代码-13符号-14有作用域的JS代码-1532位整型数-16时间戳-1764位整型数-18Min key-255Max key-127 范例： 123&gt; use studentswitched to db student&gt; db.student.find(&#123;"name":&#123;$type:2&#125;&#125;) 查找name是字符串的文档记录 limit和skip limit:读取指定数量的数据记录 -limitskip:读取时跳过指定数量的数据记录 首先查看student集合中年龄大于20的数据123456789&gt; use studentswitched to db student&gt; db.student.find(&#123;'age':&#123;$gt:20&#125;&#125;)&#123; "_id" : ObjectId("589dcf6d6ac83b9ae69f63e6"), "name" : "z", "sex" : "man", "age" : 23 &#125;&#123; "_id" : ObjectId("589dcf8f6ac83b9ae69f63e8"), "name" : "z", "sex" : "man", "age" : 29 &#125;&#123; "_id" : ObjectId("589dd11ce3b6b824fd0620e9"), "age" : 22, "name" : "ab", "sex" : "woman" &#125; 限制只显示一个数据后，默认显示最前面的数据(第一行命令不用重复编写，这里是因为markdown解析非得加上这句话才能高亮。。。)123456&gt; use studentswitched to db student&gt; db.student.find(&#123;'age':&#123;$gt:20&#125;&#125;).limit(1)&#123; "_id" : ObjectId("589dcf6d6ac83b9ae69f63e6"), "name" : "z", "sex" : "man", "age" : 23 &#125; 跳过一条数据，则可猜想显示结果为第二个数据123456&gt; use studentswitched to db student&gt; db.student.find(&#123;'age':&#123;$gt:20&#125;&#125;).limit(1).skip(1)&#123; "_id" : ObjectId("589dcf8f6ac83b9ae69f63e8"), "name" : "z", "sex" : "man", "age" : 29 &#125; pretty() 语句作用是使查询输出的结果更美观 123456789&gt; use mydb&gt; db.mydb.find().pretty()&#123; "_id" : ObjectId("589dc5f3e86d38da8455b314"), "name" : "marsggbo" &#125;&#123; "_id" : ObjectId("589dcac5e86d38da8455b315"), "name" : "mars", "age" : 12, "gender" : "man"&#125; sort() 排序 与sqlite中的排序一样有升序和降序，其中升序用1表示，降序用-1表示 示例1234567891011&gt; use studentswitched to db student&gt; db.student.find().sort(&#123;'age':1&#125;)&#123; "_id" : ObjectId("589dcf866ac83b9ae69f63e7"), "name" : "z", "sex" : "feman", "age" : 19 &#125;&#123; "_id" : ObjectId("589dd11ce3b6b824fd0620e9"), "age" : 22, "name" : "ab", "sex" : "woman" &#125;&#123; "_id" : ObjectId("589dcf6d6ac83b9ae69f63e6"), "name" : "z", "sex" : "man", "age" : 23 &#125;&#123; "_id" : ObjectId("589dcf8f6ac83b9ae69f63e8"), "name" : "z", "sex" : "man", "age" : 29 &#125; 四、数据索引ensureIndex() 索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，无疑对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库集合中一个文档或多个文档的值进行排序的一种结构。 语法： db.COLLECTION_NAME.ensureIndex({KEY:1|-1}) 同样1代表升序，-1代表降序 范例：1234&gt; use studentswitched to db student&gt; db.student.ensureIndex(&#123;"name":1&#125;) ensureIndex()的可选参数：|参数| 类型| 描述|| ——- | —–|—-|background| Boolean| 建立索引要不要阻塞其他数据库操作，默认为false|unique| Boolean| 建立的索引是否唯一，默认false|name| string| 索引的名称，若未指定，系统自动生成|dropDups|Boolean |建立唯一索引时，是否删除重复记录，默认flase||sparse |Boolean|对文档不存在的字段数据不启用索引，默认false||expireAfterSeconds| integer| 设置集合的生存时间，单位为秒||v| index version| 索引的版本号||weights| document| 索引权重值，范围为1到99999||default-language| string| 默认为英语||language_override| string| 默认值为 language|范例：1&gt; db.shiyanlou.ensureIndex(&#123;&quot;user_id&quot;:1,&quot;name&quot;:1&#125;,&#123;background:1&#125;) 总结：可以使用find进行查询，sort用于排序，ensureIndex用于建立索引，aggregate用于聚合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pyqt入门教程]]></title>
      <url>%2Fblog%2F2017%2F03%2F04%2Fpyqt%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[PyQt是一个创建GUI应用程序的工具包。它是Python编程语言和Qt库的成功融合。Qt库是目前最强大的库之一。 通过pyqt可以实现很多我们想要的功能，而且用起来十分方便，但是唯一的不足是中文资料太少，所以刚开始用的时候会比较麻烦，不过没关系，有了我这么个系列教程，入门还是可以的，反正我是靠这个完成了邮件管理软件的设计，虽然很low~~~ 下面附上链接：pyqt样式表语法笔记(上) –原创 pyqt样式表语法笔记(中) –原创 pyqt样式表语法笔记(下) –原创 written by MARSGGBO2017-2-14]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim使用笔记]]></title>
      <url>%2Fblog%2F2017%2F03%2F04%2Fvim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[本文主要记录自己在使用linux以及vim编辑器的过程中常用到的快捷键。 一、Linux 1、删除文件|文件夹12345# 删除文件$ rm filename# 删除文件夹$ rm -r dirctory 2、重命名1$ mv oldname newname 例子：将/a目录移动到/b下，并重命名为c 1mv /a /b/c 二、vim 1、移动到行首、行尾 普通模式下: 移动到行首:0移动到行尾:$ 2、删除整行 普通模式: dd 3、编辑多个文件和切换文件 3.1 一次打开多个文件1vim file1 file2 ... file6 3.2 切换文件命令模式:1:open filename 3.3 多窗口编辑文件 命令行模式下输入:sp 1.txt 打开新的横向视窗来编辑1.txt 命令行模式下输入:vsp 2.txt 打开新的纵向视窗来编辑1.txt 普通模式下Ctrl-w s 将当前窗口分割成两个水平的窗口 普通模式下Ctrl-w v 将当前窗口分割成两个垂直的窗口 普通模式下Ctrl-w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q! 普通模式下Ctrl-w o 打开一个视窗并且隐藏之前的所有视窗 普通模式下Ctrl-w j 移至下面视窗 普通模式下Ctrl-w k 移至上面视窗 普通模式下Ctrl-w h 移至左边视窗 普通模式下Ctrl-w l 移至右边视窗 普通模式下Ctrl-w J 将当前视窗移至下面 普通模式下Ctrl-w K 将当前视窗移至上面 普通模式下Ctrl-w H 将当前视窗移至左边 普通模式下Ctrl-w L 将当前视窗移至右边 普通模式下Ctrl-w - 减小视窗的高度 普通模式下Ctrl-w + 增加视窗的高度 4、跳到指定行普通模式下: 行数 gg行数 G 5、复制剪切粘贴 剪切 1.首先，可以在命令模式下输入v进入自由选取模式，选择需要剪切的文字后，按下d就可以进行剪切了。 2.其他命令模式下剪切命令： dd：剪切当前行ndd：n表示大于1的数字，剪切n行dw：从光标处剪切至一个单子/单词的末尾，包括空格de：从光标处剪切至一个单子/单词的末尾，不包括空格d$：从当前光标剪切到行末d0：从当前光标位置（不包括光标位置）剪切之行首d3l：从光标位置（包括光标位置）向右剪切3个字符d5G：将当前行（包括当前行）至第5行（不包括它）剪切d3B：从当前光标位置（不包括光标位置）反向剪切3个单词dH：剪切从当前行至所显示屏幕顶行的全部行dM：剪切从当前行至命令M所指定行的全部行dL：剪切从当前行至所显示屏幕底的全部行 复制 1.首先，可以在命令模式下输入v进入自由选取模式，选择需要剪切的文字后，按下d就可以进行剪切了。2.其他命令模式下剪切命令： yy：复制当前行nyy：n表示大于1的数字，复制n行yw：从光标处复制至一个单子/单词的末尾，包括空格ye：从光标处复制至一个单子/单词的末尾，不包括空格y$：从当前光标复制到行末y0：从当前光标位置（不包括光标位置）复制之行首y3l：从光标位置（包括光标位置）向右复制3个字符y5G：将当前行（包括当前行）至第5行（不包括它）复制y3B：从当前光标位置（不包括光标位置）反向复制3个单词 粘贴普通模式下输入p即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-sorted排序详解]]></title>
      <url>%2Fblog%2F2017%2F03%2F04%2Fpython-sorted%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1. operator函数在介绍sorted函数之前需要了解一下operator函数。 operator函数是python的内置函数，提供了一系列常用的函数操作比如，operator.mul(x, y)等于x+y1234a = [1,2,3]b = [5,6,7]c = map(operator.mul, a, b)# c的值就为[5, 12, 21] 这里只介绍它的itemgetter() 方法，更多的介绍可参考官网。operator — Standard operators as functions operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号），下面看例子。1234567a = [1,2,3] &gt;&gt;&gt; b=operator.itemgetter(1) //定义函数b，获取对象的第1个域的值&gt;&gt;&gt; b(a) 2 &gt;&gt;&gt; b=operator.itemgetter(1,0) //定义函数b，获取对象的第1个域和第0个的值&gt;&gt;&gt; b(a) (2, 1) 2. sorted函数函数介绍：Built-in Function官网示例：Sorting HOW TO¶函数原型：sorted(iterable[, cmp[, key[, reverse]]]) Return a new sorted list from the items in iterable.(会返回一个重新排列好的list)iterable(可迭代):可以是list也可以是dictcmp:可以自定义比较规则，这里不详细叙述key:用于比较的值reverse:指定是顺序还是逆序 下面以dict排序为例做讲解：1234567c = &#123;'a': 15, 'ab': 6, 'bc': 16, 'da': 95&#125;d = sorted(c.iteritems(),key=operator.itemgetter(0),reverse=True)&gt;&gt;&gt; [('da', 95), ('bc', 16), ('ab', 6), ('a', 15)]e = sorted(c.iteritems(),key=operator.itemgetter(0),reverse=True)&gt;&gt;&gt;['da', 'bc', 'a', 'ab'] 1.注意区分dict加与不加iteritems() 对于结果的影响2.我们的key选择的是传入参数的第0号元素，在这里即是键(keys),所以最终的排序是按照键排序，我们也可以以值作为标准进行排序，看下面示例12d = sorted(c.iteritems(),key=operator.itemgetter(1),reverse=True)&gt;&gt;&gt; [('da', 95), ('bc', 16), ('a', 15), ('ab', 6)] 看到这你会不会觉得operator的itemgetter函数可以用lambda函数实现：我们可以将上面的示例改成lambda12d = sorted(c.iteritems(),key=lambda x:x[1],reverse=True)&gt;&gt;&gt; [('da', 95), ('bc', 16), ('a', 15), ('ab', 6)] 你看结果是一样一样的。 文章参考：Python中的sorted函数以及operator.itemgetter函数python中的operator库 written by MARSGGBO2017-2-14]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见算法排序-python实现]]></title>
      <url>%2Fblog%2F2017%2F03%2F04%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F-python%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[1.二分法12345678910111213141516171819202122232425262728293031#coding=utf-8def binary_search(input_array, value): """Your code goes here.""" length = len(input_array) left = 0 right = length-1 if length == 1: return 0 if value == input_value[0] else -1 else: mid = (left+right)/2 while(right-left&gt;1): if input_array[mid] == value: return mid elif input_array[mid] &gt; value: right = mid mid = (left+right)/2 else: left = mid mid = (left+right)/2 if input_array[left] == value: return left elif input_array[right] == value: return right else: return -1test_list = [1,3,9,11,15,19,29]test_val1 = 25test_val2 = 15print (binary_search(test_list, test_val1))print (binary_search(test_list, test_val2)) 2.冒泡法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding=utf-8# way=1递增排序 way=0递减排序def bubble_sort(array,way=1): length = len(array) if not length: print("Error!The length of array must be greater than 0.\n") return 'Wrong array' if way == 1: while length &gt; 0: for i in range(length-1): if array[i] &gt; array[i+1]: array[i],array[i+1] = array[i+1],array[i] length -= 1 return array elif way == 0: while length &gt; 0: for i in range(length-1): if array[i] &lt; array[i+1]: array[i],array[i+1] = array[i+1],array[i] length -= 1 return array# 加入排序判断标志，可提高运行效率# way=1递增排序 way=0递减排序def better_bubble_sort(array,way=1): is_sorted = True # 判断记录上次遍历是否进行过交换，若没有则表示不用再遍历了 length = len(array) if not length: print("Error!The length of array must be greater than 0.\n") return 'Wrong array' if way == 1: while length &gt; 0 and is_sorted: for i in range(length-1): is_sorted = False if array[i] &gt; array[i+1]: array[i],array[i+1] = array[i+1],array[i] is_sorted = True length -= 1 return array elif way == 0: while length &gt; 0 and is_sorted: for i in range(length-1): is_sorted = False if array[i] &lt; array[i+1]: array[i],array[i+1] = array[i+1],array[i] is_sorted = True length -= 1 return arraytest = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14] print(better_bubble_sort(test,1)) 3.插入排序123456789101112131415161718#coding=utf-8def insert_sort(array): length = len(array) flag = array[0] for x in range(1,length): # 之前的 if array[x] &lt; array[x-1]: flag = array[x] y = x while y != 0 and array[y-1] &gt; flag : array[y] = array[y-1] y -= 1 array[y] = flag return arraytest = [21, 4, 1, 3, 9, 20, 25, 20, 3]print(insert_sort(test)) 4.归并排序123456789101112131415161718192021222324252627282930#coding=utf-8def merge_sort(array): if len(array) &lt;= 1: return array split_index = len(array)/2 left = merge_sort(array[:split_index]) right = merge_sort(array[split_index:]) return merge(left,right)def merge(left,right): i = 0 j = 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += (left[i:]) result += (right[j:]) return resulta = [1,2]test = [21, 4, 1, 3, 9, 20, 25] print(merge_sort(test)) 5.选择排序123456789101112131415#coding=utf-8def select_sort(array): length = len(array) # mini = array[0] for i in range(length): mini = array[i] for j in range(i,length): if array[j] &lt; mini: mini = array[j] array[i],array[j] = array[j],array[i] return arraytest = [21, 4, 1, 3, 9, 20, 25, 20, 3] print(select_sort(test)) 6.快速排序12345678910111213141516171819202122232425#coding=utf-8# 递归def quick_sort(lists, left, right): # 快速排序 if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return liststest = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]print (quick_sort(test,0,len(test)-1)) written by MARSGGBO2017-2-14]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flask模板教程笔记]]></title>
      <url>%2Fblog%2F2017%2F02%2F06%2Fflask%E6%A8%A1%E6%9D%BF%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0(%E8%BF%87%E6%BB%A4%E5%99%A8)%2F</url>
      <content type="text"><![CDATA[以下笔记的记录方式主要是以实际要求作为背景，然后介绍具体的解决办法来行文。 1、在模板中调用自定义的过滤器 问题背景 之所以要用到自定义的过滤器是因为我自己在做一个博客，博客中有使用markdown语法编辑文章的页面，而最后数据库保存的文章内容是markdown格式而不是html格式，因为我认为这样会节省空间一些，如果要显示文章，只需将markdown格式解析一下即可。 问题 但是现在遇到的问题就是何时解析markdown格式。我使用的数据库是flask-sqlalchemy。我首先通过视图函数将 数据表(articles) 传给模板,代码如下123articles = Article.query.all()...return render_template('edit.html',articles=articles) 在需要渲染文章内容的时候我理所应当的使用for循环来逐个渲染，文章的标题、分类和标签这些信息都非常好处理，但是轮到markdown格式的文章内容的时候我懵了，我知道需要解析成html格式，但是在html模板中我不知道怎么在模板中调用python。 解决办法后来在麦子学院看了视频茅塞顿开(其实就是教程里给出了解决办法。。。)，可以通过使用过滤器来解决这个问题。使用方法如下： 首先注册过滤器 views.py12345678910@app.template_filter('md')def markdown_to_html(md): import markdown return markdown.markdown(md)@app.route('index')def index(): articles = Article.query.all() ... return render_template('edit.html',articles=articles) - 在模板中使用md过滤器，用法为 **{{ 变量|md }}** index.html1234567891011121314&#123;% for article in articles %&#125;&lt;header class="article-header"&gt; &lt;h1 class="article-title"&gt; &#123;&#123; article.title &#125;&#125; &lt;/h1&gt; &lt;div class="article-mata"&gt; &lt;span class="article-categories"&gt; &lt;a href=""&gt;&#123;&#123; article.categories &#125;&#125;&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="article-body"&gt; &#123;&#123; article.content|md|safe &#125;&#125; &lt;/div&gt;&lt;/header&gt; 效果展示 2、flask上下文 问题背景 背景与上面的类似，只是这里是如何解析本地的md文件 问题如何在模板中调用外部函数？ 解决办法使用上下文装饰器，用法如下： 首先定义好需要调用的外部函数12345def read_md(filename): from markdown import markdown with open(filename,'rb') as f: data = reduce(lambda x , y:x + y,f.readlines()) return markdown(data.decode('utf-8')) - 注册上下文 123@app.context_processordef inject_methods(): return dict(read_md=read_md) - 在模板中调用即可 加入&apos;hello.md&apos;在同级目录下 1&#123;&#123; read_md('hello.md') &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剑指Offer_编程题大集结]]></title>
      <url>%2Fblog%2F2017%2F01%2F20%2F%E5%89%91%E6%8C%87Offer-%E7%BC%96%E7%A8%8B%E9%A2%98%E5%A4%A7%E9%9B%86%E7%BB%93%2F</url>
      <content type="text"><![CDATA[剑指Offer_编程题大集结以下题目摘自牛客网，仅供学习，欢迎大家互相交流学习。 1、 二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011# -*- coding:utf-8 -*-class Solution:# array 二维列表def Find(self, target, array): # write code here flag = False for item in array: if target in item: flag = True break return flag 2、替换空格 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456# -*- coding:utf-8 -*-class Solution:# s 源字符串 def replaceSpace(self, s): # write code here return s.replace(' ','%20') 3、从尾到头打印链表 输入一个链表，从尾到头打印链表每个节点的值。 123456789101112131415# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here box = [] while listNode: box.insert(0,listNode.val) listNode = listNode.next return box 4、重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre): root = TreeNode(pre[0]) # 找到根节点在中序遍历序列中的位置 rootIndex = tin.index(pre[0]) root.left = self.reConstructBinaryTree(pre[1:rootIndex+1],tin[:rootIndex]) root.right = self.reConstructBinaryTree(pre[rootIndex+1:],tin[rootIndex+1:]) return root else: return None 5、用两个栈实现队列 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if len(self.stack2): return self.stack2.pop() else: while len(self.stack1) != 0: self.stack2.append(self.stack1.pop()) return self.stack2.pop() 6、旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 考察二分法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 else: left = 0 right = len(rotateArray) - 1 mid = int(right/2) # 没有旋转的情况 if rotateArray[left] &lt; rotateArray[right]: return rotateArray[left] # 旋转的情况 else: return self.dichotomization(rotateArray,left,mid,right) def dichotomization(self,rotateArray,left,mid,right): # 递归结束条件：当右指针和左指针只相差一个位置，然后判断大小即可。 # 其实也不用判断了，在该段代码中可已直接判断出最小值为右指针所指的值， # 因为若果调用了该递归函数，则表明是一个非递减数列的旋转数列 # 所以可以很容易的推测出当右指针和左指针只相差一个位置，最小值一定是右指针所指示的值 if right - left == 1 : if rotateArray[right] &lt; rotateArray[left]: return rotateArray[right] else: return rotateArray[left] else: # 递归法只适用于顺序排列而且没有重复数字的序列，如果有重复出现的数字则无法判断区间，所以只能遍历查找 if rotateArray[mid] == rotateArray[right]: return self.ergodic(rotateArray) if rotateArray[mid] &lt; rotateArray[right]: right = mid left = left mid = int((left+right+1)/2) return self.dichotomization(rotateArray,left,mid,right) else: left = mid right = right mid = int((left+right+1)/2) return self.dichotomization(rotateArray,left,mid,right) def ergodic(self,rotateArray): if len(rotateArray) == 1: return rotateArray[0] else: for i in range(len(rotateArray)): if rotateArray[i] &gt; rotateArray[i+1]: break return rotateArray[i+1]# 最简单的方法# class Solution:# def minNumberInRotateArray(self, rotateArray):# # write code here# if len(rotateArray) == 0:# return 0# else:# return min(rotateArray) 7、斐波那契数列 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: # # 递归法适用于n比较小的情况 # def Fibonacci(self, n): # # write code here # if n &lt;= 2: # return 1 # else: # return self.Fibonacci(n-1) + self.Fibonacci(n-2) # 迭代法 def Fibonacci(self, n): # write code here if n &lt; 0: return -1 elif n == 0: return 0 elif n &lt;= 2: return 1 else: a = 1 b = 1 while n &gt; 2: a,b = b,a+b n -= 1 return b 8、跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 经过简单写出几种当n比较小的情况的结果，可以看出结果一个斐波拉契数列 1234567891011121314# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): if number &lt; 1: return -1 elif number == 1: return 1 else: a = 1 b = 1 while number &gt; 1: a,b = b,a+b number -= 1 return b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flask入门笔记(四)--数据库]]></title>
      <url>%2Fblog%2F2017%2F01%2F19%2Fflask%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[这里介绍的是flask-SQLAlchemy 1、 安装扩展1pip install flask-sqlalchemy 2、 配置数据库 就这么配置吧，具体的原理以后慢慢学习。1234567891011import osbasedir = os.path.abspath(os.path.dirname(__file__)) app = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string'app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = Trueapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Truedb = SQLAlchemy(app) 3、 定义模型这里的模型是以论坛网站为背景，每个用户都扮演一个角色(Role)，即管理员、版主和普通用户。每个用户拥有自己的表单数据(User)。1234567891011121314151617class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer,primary_key=True) name = db.Column(db.String(64),unique=True) users = db.relationship('User',backref='role') def __repr__(self): return '&lt;Role %r&gt;' % self.nameclass User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer,primary_key=True) role_id = db.Column(db.Integer,db.ForeignKey('roles.id')) username = db.Column(db.String(64),unique=True,index=True) def __repr__(self): return '&lt;User %r&gt;' % self.username 4、 关系关系已经在上面的代码中显示出来了，下面只对上面的代码做一下解释。12345678910class Role(db.Model): __tablename__ = 'roles' # ... users = db.relationship('User',backref='role')class User(db.Model): __tablename__ = 'users' # ... role_id = db.Column(db.Integer,db.ForeignKey('roles.id')) db.ForeignKey()表明这一列被定义为外键，其中传入的参数是”roles.id”表明这一列的值是roles表中行的id值。 db.relationship()的第一个参数表示这个关系的另一端是哪个模型，另外backref参数想User模型中添加一个role属性，从而定义反向关系，这一属性可替代role_id访问Role模型，此时获取的是模型对象，而不是外键的值，所以课给出如下数据模型的定义：1234567admin_role = Role(name="Admin") #管理员mod_role = Role(name="Moderator") #版主user_role = Role(name="User") #普通用户user_marsA = User(username="marsA",role=admin_role)user_marsB = User(username="marsB",role=user_role)user_marsC = User(username="marsC",role=user_role) 可见User模型传入的第二个参数是模型对象，而不是具体的键值。 5、 视图函数注意之前导入表单模块是这样的from flask_wtf import Form,但是根据官方提示，因为版本升级，为了以后的代码兼容问题建议写成这样1from flask_wtf import FlaskForm 视图函数 12345678910111213141516171819class NameForm(FlaskForm): name = StringField('Whats your name?', validators=[Required()]) submit = SubmitField('Submit')@app.route('/',methods=['GET','POST'])def index(): form = NameForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.name.data).first() if user is None: user = User(username = form.name.data) db.session.add(user) session['known'] = False else: session['known'] = True session['name'] = form.name.data form.name.data = '' return redirect(url_for('index')) return render_template('index.html',form=form,name=session.get('name'),known=session.get('known')) 基模板 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &#123;% block head %&#125; &lt;title&gt;&#123;% block title%&#125;&#123;% endblock %&#125;-Base HTML&lt;/title&gt; &lt;style type="text/css"&gt;&#123;% block style %&#125;&#123;% endblock %&#125;&lt;/style&gt; &lt;link rel="stylesheet" type="text/css" href="../static/bootstrap.css"&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block navbar %&#125; &lt;div class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="\"&gt;Download&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endblock%&#125; &#123;% block content %&#125; &lt;div class="container"&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125; &lt;/div&gt; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 衍生模板 1234567891011121314151617181920212223242526272829&#123;% extends "base.html" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125; &lt;div class="page-header"&gt; &lt;h1 class="text-center"&gt;Flask-WTF&lt;/h1&gt; &lt;h1 class="text-center"&gt; Hello,&#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;! &lt;/h1&gt; &lt;div class="container"&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class="alert alert-warning"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#123;&#123; message&#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% if known %&#125; &lt;h3 class="text-center"&gt;Nice to See you again!&lt;/h3&gt; &#123;% else %&#125; &lt;h3 class="text-center"&gt;Nice to meet you!&lt;/h3&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;form method="POST"&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label &#125;&#125;&#123;&#123; form.name(id='my-text-field', class="form-control" )&#125;&#125; &#123;&#123; form.submit(class='btn btn-info form-control') &#125;&#125; &lt;/form&gt; &lt;/div&gt;&#123;% endblock %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask入门笔记（三）--web表单]]></title>
      <url>%2Fblog%2F2017%2F01%2F18%2FFlask%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-web%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[4.1 跨站请求伪造保护 12app = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string' 4.2 表单类导入flask的表单扩展方法：（之前的版本是flask.ext.wtf,建议还是用flask_wtf） 12from flask_wtf import Formfrom wtforms import StringField,PasswordField WTForms支持的HTML标准字段 字段类型 说明 字段类型 说明 StringField 文本字段 BooleanField 复选框(True/False) TextAreaField 多行文本字段 RadioField 单选框 PasswordField 密码文本字段 SelectField 下拉列表 HiddenField 隐藏文本字段 SelectMultipleField 可多选下拉列表 DateField 值为datetime.date格式 FileField 文件上传字段 DateTimeField 值为datetime.datetime格式 SubmitField 提交字段 IntegerField 文本字段,整型 FormField 把表单嵌入到另一个表单 DecimalField 文本字段，十进制 FieldList 一组指定类型的字段 FloatField 文本字段，浮点型 WTForms验证函数 验证函数 说明 验证函数 说明 Email 验证电子邮件格式 Optional 无输入值时跳过其他验证函数 EqualTo 比较两字段的值，常用于账号注册，如输入两次密码 Required 确保字段中有数据 IpAddress 验证Ipv4地址 Regexp 使用正则验证 Length 验证字符串长度 URL 验证URL NumberRange 验证输入值在指定范围内 Anyof 确保输入值在可选值列表中 Noneof 确保输入值不在可选值列表中 使用步骤： 首先创建表单类 123class NameForm(Form): name = StringField('Hello?', validators=[Required()]) submit = SubmitField('Submit') 把表单渲染成HTML我这里使用到了模板继承，下面给出基模板和衍生模板 基模板 base.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &#123;% block head %&#125; &lt;title&gt;&#123;% block title%&#125;&#123;% endblock %&#125;-Base HTML&lt;/title&gt; &lt;style type="text/css"&gt;&#123;% block style %&#125;&#123;% endblock %&#125;&lt;/style&gt; &lt;link rel="stylesheet" type="text/css" href="../static/bootstrap.css"&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block navbar %&#125; &lt;div class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="\"&gt;Download&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endblock%&#125; &#123;% block content %&#125; &lt;div class="container"&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125; &lt;/div&gt; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 衍生模板 index.html 123456789101112131415161718192021222324&#123;% extends "base.html" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125; &lt;div class="page-header"&gt; &lt;h1 class="text-center"&gt;Flask-WTF&lt;/h1&gt; &lt;h1 class="text-center"&gt; Hello,&#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;! &lt;/h1&gt; &lt;div class="container"&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class="alert alert-warning"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#123;&#123; message&#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;form method="POST"&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label &#125;&#125;&#123;&#123; form.name(id='my-text-field', class="form-control" )&#125;&#125; &#123;&#123; form.submit(class='btn btn-info form-control') &#125;&#125; &lt;/form&gt; &lt;/div&gt;&#123;% endblock %&#125; 在视图函数中处理表单123456789@app.route('/',methods=['GET','POST'])def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data print("form:",form,'\n',"form.name:",form.name,'\n',"form.name.label:",form.name.label,'\n','name:',name) form.name.data = '' return render_template('index.html',form=form,name=name) 局部变量name用于获取表单中用户输入的信息，其中提交表单后，若通过验证(第一步骤中的表单类的 name = StringField(‘Hello?’, ==validators=[Required()]==) 使用了验证函数),若通过验证，则 form.validate_on_submit() 返回True,然后渲染表单页面。 4.3 重定向和用户会话使用redirect和url_for()。1234567@app.route('/redirect',methods=['GET','POST'])def redirect_(): form = NameForm() if form.validate_on_submit(): session['name'] = form.name.data return redirect(url_for('redirect_')) return render_template('index.html',form=form,name=session.get('name')) 注意url_for()中的值要与函数名相匹配 4.4 flash消息12345678910@app.route('/flash',methods=['GET','POST'])def flash_(): form = NameForm() if form.validate_on_submit(): old_name = session.get('name') if old_name and old_name != form.name.data: flash('You new name is %s!'%form.name.data) session['name'] = form.name.data return redirect(url_for('flash_')) return render_template('index.html',form=form,name=session.get('name')) 使用flash方法，光这样还不行，还需要在模板中渲染flash。Flask把get_flashed_messages() 函数开放给模板，用于渲染flash消息。代码示例：12345678&lt;div class="container"&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class="alert alert-warning"&gt; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#123;&#123; message&#125;&#125; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用两个栈实现队列]]></title>
      <url>%2Fblog%2F2017%2F01%2F17%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[首先栈的特点是“先进后出”，队列则是“先进先出”，所以要实现用两个栈来实现一个队列, 可按照如下思路：假设两个栈分别叫stack1和stack2，Python中的list的append方法可当做入栈，pop则为出栈。 如果进行入队列操作，则将数据加入stack1中，即stack1.append(data) 一旦进行出队列操作，则首先查看stack2中是否有数据 如果有数据，则先将stack2中的数据弹出，即实现出队列操作 如果没有数据，则将stack1中所有的数据都pop()到stack2中，这样就可以实现倒序，即最先进入stack1的位于stack2的最上面，所以下次stack2进行pop()操作时就与队列操作规则相统一了。 代码实现:12345678910111213141516# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if len(self.stack2): return self.stack2.pop() else: while len(self.stack1) != 0: self.stack2.append(self.stack1.pop()) return self.stack2.pop() 光说不练假把式，举个栗子。假设数据为1,2,3,4.执行的操作时[push1,push2,push3,pop,pop,push4,pop,pop] 首先数据1,2,3进入栈1,即 [push1,push2,push3] 操作 下面进行 [pop,pop] 操作，首先会判断栈2是否为空，因为是空的，所以需要先将栈1中所有数据pop到栈2，如下图 因为只有两次pop操作，所以栈2中还有数据3等待弹出。而后又加入了4，即进入栈1.如下图 最后进行两次pop操作，先分析第一次pop操作。因为栈2中还有数据3，所以栈1中的数据4不用出栈，直接将数据3弹出即可。得到下图 最后一次pop操作，需要先将栈1中的数据4弹出，并压到栈2中如下图 然后再对2执行pop操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask入门笔记（二）--模板]]></title>
      <url>%2Fblog%2F2017%2F01%2F16%2FFlask%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[1. 渲染模板使用了Jinja2模板引擎render_template 1from flask import render_template,Flask 2. 变量Jinja2变量过滤器 过滤器名 说明 safe 渲染值时不转义 capitalize 把值的首字母转换成大写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大 写 trim 把值的首尾空格去掉 striptags 渲染之前把值中所有的HTML标签都删掉 示例12# html文件hello &#123;&#123; name|capitalize&#125;&#125; 3. 控制结构 条件控制语句 12345&#123;% if user %&#125; Hello, &#123;&#123; user &#125;&#125;&#123;% else %&#125; Hello, Stranger!&#123;% endif %&#125; for循环 12345&lt;ul&gt; &#123;% for comment in comments %&#125; &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; Jinja2中支持宏。例如123456789&#123;% macro render_comment(comment)%&#125; &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;&#123;% endmacro %&#125;&lt;ul&gt; &#123;% for comment in comments %&#125; &#123;&#123; render_comment(comment) &#125;&#125; &#123;% endfor %&#125;&lt;/ul&gt; 有时会重复使用宏，所以最好保存在单独的文件中，然后在需要使用的模板中导入即可。 1234567&#123;% import 'macro.html' as macro %&#125;&lt;ul&gt; &#123;% for comment in comments %&#125; &#123;&#123; macro.render_comment(comment) &#125;&#125; &#123;% endfor %&#125;&lt;/ul&gt; 使用模板 另一种重复使用代码的强大方式是模板继承。首先，创建一个名为base.html的及模板:123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &#123;% block head %&#125; &lt;title&gt;&#123;% block title%&#125;&#123;% endblock %&#125;-Base HTML&lt;/title&gt; &lt;style type="text/css"&gt;&#123;% block style %&#125;&#123;% endblock %&#125;&lt;/style&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; 这是基模板 &#123;% block body%&#125; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 衍生模板123456789101112131415&#123;% extends "base.html "%&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block style %&#125; body&#123; background-color: tomato; &#125;&#123;% endblock %&#125;&#123;% block head %&#125; &#123;&#123; super() &#125;&#125;&#123;% endblock %&#125;&#123;% block body %&#125; &lt;h1&gt;这是衍生模板&lt;/h1&gt;&#123;% endblock %&#125; 效果图： 注意衍生模板中的title和style需要放在head的上面，即如果衍生模板代码是下面这样的就会重复显示内容123456789101112131415&#123;% extends "base.html "%&#125;&#123;% block head %&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block style %&#125; body&#123; background-color: tomato; &#125;&#123;% endblock %&#125; &#123;&#123; super() &#125;&#125;&#123;% endblock %&#125;&#123;% block body %&#125; &lt;h1&gt;这是衍生模板&lt;/h1&gt;&#123;% endblock %&#125; 如下图 之所以会这样，我的理解是title和style都是head的子元素，之所以要放在head的前面是因为有 super() 这个方法会获取原来的内容，并插入到适当的位置。 自定义错误页面 1234567@app.errorhandler(404)def page_not_find(e): return render_template('404.html'),404@app.errorhandler(500)def interval_server_error(e): return render_template('500.html'),500]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask入门笔记(一)]]></title>
      <url>%2Fblog%2F2017%2F01%2F12%2FFlask%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[一、程序的基本结构 1.1 最简单的Flask程序1234567891011121314#coding=utf-8# 初始化from flask import Flaskapp = Flask(__name__)# 路由视图函数@app.route('/')def index(): return '&lt;h1&gt;Hello World&lt;/h1&gt;'if __name__ == '__main__': # 启动服务器 app.run(debug=True) 1.2 请求响应循环 1. 程序和请求上下文 变量名 上下文 说明 current_app 程序上下文 当前激活程序的程序实例 g 程序上下文 处理请求时用作临时存储的对象。每次请求都会重会设这个变量 request 请求上下文 请求对象，封装了客户端发出的HTTP请求中的内容 session 请求上下文 用户会话，用于存储请求之间需要“记住”的值的词典 2. 请求调度Get、HEAD、Options 3. 请求钩子 类型 作用 before_first_request 注册一个函数，在处理第一个请求之前运行 before_request 注册一个函数,在每次请求之前运行 after_request 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行 teardown_request 注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo使用笔记]]></title>
      <url>%2Fblog%2F2016%2F12%2F03%2Fhexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[一、创建新页面 下面假如我要创建一个个人介绍的单独页面，具体步骤如下： 第一步：新建页面 12$ cd your-hexo-site$ hexo new page about 之后会出现如下提示 第二步：设置页面类型 新建页面后，会在source目录下创建和你命名的一个同步的文件夹，文件夹中有一个index.md文件，之后的个人简介可以在这里展示。文件结构如下图 之后打开index.md文件，将文件类型标注为about即可123456---title: aboutdate: 2016-12-03 23:45:44comments: falsetype: &apos;about&apos;--- 第三步：修改主题配置文件 12345menu: home: / archives: /archives tags: /tags about: /about 注：如果你开启了多说评论，但是在个人介绍页面不想显示多说，可以再添加comments: false禁止多说,如下123456---title: aboutdate: 2016-12-03 23:45:44type: 'about'comments: false---]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python多线程学习笔记-超详细]]></title>
      <url>%2Fblog%2F2016%2F12%2F03%2Fpython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B6%85%E8%AF%A6%E7%BB%86%2F</url>
      <content type="text"><![CDATA[一. Threading简介 首先看下面的没有用Threading的程序 1234567891011121314151617181920import threading,timedef fun(): s = 0 for i in range(30): s += i time.sleep(0.1) print(s)if __name__ == '__main__': t = time.time() fun() fun() print(time.time()-t) &gt;&gt;&gt; 4354356.023701906204224[Finished in 6.6s] 如果使用线程会有什么样的效果呢 12345678910111213141516171819202122232425import threading,timedef fun(): s = 0 for i in range(30): s += i time.sleep(0.1) print(s)if __name__ == '__main__': # 创建了一个线程列表，包含2个线程 ths = [threading.Thread(target=fun) for i in range(2)] for th in ths: th.start() t = time.time() for th in ths: th.join() print(time.time()-t) &gt;&gt;&gt; 4354353.116874933242798[Finished in 3.7s] 这说明两个线程几乎是同时进行的 二. Threading的应用进阶 1) join(timeout)用来实现线程等待。被调用join()方法的线程会一直阻塞调用者的线程，直到自己结束（正常结束，或引发未处理异常），或超出timeout的时间。12345678910111213141516171819202122232425262728293031323334353637383940import threading,timeclass MyThread(threading.Thread): def run(self): for i in range(30): print('threading:',i) time.sleep(0.1)if __name__ == '__main__': t = MyThread() t.start() t.join(1) for i in range(10): print('Main:',i) time.sleep(0.1) &gt;&gt;&gt; threading: 0threading: 1threading: 2主线程等待t这个线程0.1秒后也开始运行Main: 0threading: 3Main: 1threading: 4Main: 2threading: 5Main: 3threading: 6Main: 4threading: 7Main: 5threading: 8Main: 6threading: 9Main: 7Main: 8Main: 9[Finished in 2.0s] 注意每次运行的结果都不太一样 2)daemon属性被设定为后台运行的线程，会在主程序退出时主动自杀。设置为后台运行线程的方法是：==设置线程的daemon属性为True==123456789101112131415161718192021222324252627import threading,timedef dmn(): print('dmn start...') time.sleep(2) print('dmn end.')def ndmn(): print('ndmn start...') time.sleep(1) print('ndmn end.')d = threading.Thread(target=dmn)d.daemon = Truen = threading.Thread(target=ndmn)print('start...')d.start()n.start()print('end.')&gt;&gt;&gt;start...dmn start...ndmn start...end.ndmn end.[Finished in 1.3s] 由上面打印的结果我们可以看到dmn线程设置为后台线程后，它的 print(‘dmn end.’) 语句并不没有执行，这是因为后台线程在主线程结束后会自杀，所以主线程执行完后，dmn线程没能说出自己的“遗言”。作为对比，我将==daemon==设为False，结果如下1234567891011121314...d = threading.Thread(target=dmn) d.daemon = False ...&gt;&gt;&gt;start...dmn start...ndmn start...end.ndmn end.dmn end.[Finished in 2.5s] 3) 线程同步1 )指令锁 threading.Lock acquire尝试获得锁定，进入阻塞状态。acquire(blocking=True, timeout=－1)) release释放获得锁定（资源使用完后）release()123456789101112131415161718192021222324252627282930313233343536import threading,time,randomshare = 4 lock = threading.Lock() #初始化指令锁class MyThread(threading.Thread): def __init__(self,i): super().__init__() self.i = i def run(self): global share for d in range(2): lock.acquire() print(share) share += self.i time.sleep(random.random()) print('+',self.i,'=',share) lock.release()if __name__ == '__main__': t = MyThread(2) tt = MyThread(6) t.start() tt.start() &gt;&gt;&gt;4+ 2 = 66+ 6 = 1212+ 2 = 1414+ 6 = 20[Finished in 2.9s] 为了更好的感受指令锁的作用，将acquire和release去掉后结果如下12345678910111213141516171819202122...def run(self): global share for d in range(2): # lock.acquire() print(share) share += self.i time.sleep(random.random()) print('+',self.i,'=',share) # lock.release() ...&gt;&gt;&gt;46+ 6 = 1212+ 2 = 1818+ 6 = 20+ 2 = 20[Finished in 2.2s] 比较后可以知道，加了指令锁后可以清楚地知道对共享资源share操作的具体情况 2 )条件变量threading.Condition属性 实例化时，可指定锁。 acquire() release() wait(timeout=None)释放锁，进入等待阻塞，直到唤醒或超时。 notify(n=1)唤醒等待该条件变量的线程。默认1个。 notify_all()唤醒等待该条件变量的所有线程。 实现严格的依照次序操作的线程之间的通信。典型的实例：==生产者/消费者==（只有生产后，才能消费）。线程之间可以互相通知，以达到默契的配合。条件变量可以使用默认的锁或用户创建的锁来工作。 话不多说看代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import threading,timeshare = 0share_cond = threading.Condition()# 生产者class ProThread(threading.Thread): def __init__(self): super().__init__() self.name = 'Produce' def run(self): global share if share_cond.acquire(): while True: if not share: # 若没东西了，即开始生产 share += 1 print(self.name,share) share_cond.notify() #唤醒消费者？这个是我自己的理解 share_cond.wait() time.sleep(1)# 消费者class CustomThread(threading.Thread): def __init__(self): super().__init__() self.name = 'Custom' def run(self): global share if share_cond.acquire(): while True: if share: share -= 1 # 若有东西就买买买 print(self.name,share) share_cond.notify() #唤醒生产者，同上，仅是个人理解，如有错请告知，谢谢 share_cond.wait() time.sleep(1)if __name__ == '__main__': t = ProThread() tt = CustomThread() t.start() tt.start()&gt;&gt;&gt;Produce 1Custom 0Produce 1Custom 0Produce 1Custom 0......... 上面的结果会一直重复执行下去 3 ) 信号量threading.Semaphore 属性 实例化时，指定使用量。 其内置计数器，锁定时+1，释放时－1，计数器为0则阻塞。 acquire(blocking=True,timeout=None) release()释放锁。 123456789101112131415161718192021222324252627282930313233import threading,timesema = threading.Semaphore(2)class MyThread(threading.Thread): def __init__(self,name): super().__init__() self.name = name def run(self): if sema.acquire(): print(self.name,'Had got resource.') time.sleep(1) sema.release() print(self.name,'Had released resource.')if __name__ == '__main__': ths = [MyThread(str(i)+'Sema') for i in range(5)] for th in ths: th.start() &gt;&gt;&gt;0Sema Had got resource.1Sema Had got resource.2Sema Had got resource.1Sema Had released resource.3Sema Had got resource.0Sema Had released resource.3Sema Had released resource.4Sema Had got resource.2Sema Had released resource.4Sema Had released resource.[Finished in 3.6s] 4 ) 线程通信threading.Event 其管理一个内部标志.实现一个线程，唤醒其它线程。 set() 设置内部标志为True clear() 设置内部标志为False wait(timeout)阻塞线程，到内部标志为True。 1234567891011121314151617181920212223242526272829import threading,timeevent = threading.Event()class MyThreadWait(threading.Thread): def run(self): self.name = 'Wait Thread' print(self.name,"Wait...") event.wait() print(self.name,"Start...") event.clear()class MyThreadMain(threading.Thread): def run(self): time.sleep(3) print('Main thread set event flag!') event.set()if __name__ == '__main__': thw = MyThreadWait() thm = MyThreadMain() thw.start() thm.start() &gt;&gt;&gt;Wait Thread Wait...Main thread set event flag!Wait Thread Start...[Finished in 3.6s] 好了，大概就是这些了，其他的以后再补充，另外感谢麦子学院提供的免费课程~~~真心不是打广告为了避嫌，顺便感谢一下imooc，极客学院~很多都是从这些造福人类的网站学到的。另附上麦子学院的视频教程，毕竟要学会感恩嘛http://www.maiziedu.com/course/644-9663/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DataCamp 机器学习笔记]]></title>
      <url>%2Fblog%2F2016%2F12%2F02%2FDataCamp-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[一、 Get the Data with Pandas链接中的csv包含的数据是Titanic乘客的数据,大体数据在文末有显示。1234567891011121314# Import the Pandas libraryimport pandas as pd# Load the train and test datasets to create two DataFramestrain_url = "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/train.csv"train = pd.read_csv(train_url)test_url = "http://s3.amazonaws.com/assets.datacamp.com/course/Kaggle/test.csv"test = pd.read_csv(test_url)print(type(train))&gt;&gt;&gt;&lt;class 'pandas.core.frame.DataFrame'&gt; 二、 Understanding your data 1、 .describe()作用详见代码 1234567891011In [1]: test.describe()Out[1]: PassengerId Pclass Age SibSp Parch Farecount 418.000000 418.000000 332.000000 418.000000 418.000000 417.000000mean 1100.500000 2.265550 30.272590 0.447368 0.392344 35.627188std 120.810458 0.841838 14.181209 0.896760 0.981429 55.907576min 892.000000 1.000000 0.170000 0.000000 0.000000 0.00000025% 996.250000 1.000000 21.000000 0.000000 0.000000 7.89580050% 1100.500000 3.000000 27.000000 0.000000 0.000000 14.45420075% 1204.750000 3.000000 39.000000 1.000000 0.000000 31.500000max 1309.000000 3.000000 76.000000 8.000000 9.000000 512.329200 2、 .shape 注意没有括号 12345678910In [2]: test.shape()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; test.shape()TypeError: 'tuple' object is not callableIn [3]: test.shapeOut[3]: (418, 11) 3、 value_counts()用于统计某一项的数据情况。例如train中包含有乘客生还信息，即”Survived”一项，1表示活，0表示die。下面用value_counts()来统计生还情况。12345In [2]: train['Survived'].value_counts()Out[2]: 0 5491 342Name: Survived, dtype: int64 value_counts()中还有 normalize 参数可以设定，若设定为 True，则会将结果以比率的形式显示12345In [3]: train['Survived'].value_counts(normalize=True)Out[3]: 0 0.6161621 0.383838Name: Survived, dtype: float64 三、 Intro to decision trees 学习使用 scikit-learn library 1、 Creating your first decision tree1234567891011# Create the target and features numpy arrays: target, features_onetarget = train['Survived'].valuesfeatures_one = train[["Pclass", "Sex", "Age", "Fare"]].values# Fit your first decision tree: my_tree_onemy_tree_one = tree.DecisionTreeClassifier()my_tree_one = my_tree_one.fit(features_one, target)# Look at the importance and score of the included featuresprint(my_tree_one.feature_importances_)print(my_tree_one.score(features_one, target)) target: A one-dimensional numpy array containing the target/response from the train data. (Survival in your case)features: A multidimensional numpy array containing the features/predictors from the train data. (ex. Sex, Age) .featureimportances &amp; .score() 介绍 One way to quickly see the result of your decision tree is to see the importance of the features that are included. This is done by requesting the .featureimportances attribute of your tree object. Another quick metric is the mean accuracy that you can compute using the .score() function with features_one and target as arguments. train数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192In [1]: trainOut[1]: PassengerId Survived Pclass \0 1 0 3 1 2 1 1 2 3 1 3 3 4 1 1 4 5 0 3 5 6 0 3 6 7 0 1 7 8 0 3 8 9 1 3 9 10 1 2 10 11 1 3 11 12 1 1 12 13 0 3 13 14 0 3 14 15 0 3 15 16 1 2 16 17 0 3 17 18 1 2 18 19 0 3 19 20 1 3 20 21 0 2 21 22 1 2 22 23 1 3 23 24 1 1 24 25 0 3 25 26 1 3 26 27 0 3 27 28 0 1 28 29 1 3 29 30 0 3 .. ... ... ... 861 862 0 2 862 863 1 1 863 864 0 3 864 865 0 2 865 866 1 2 866 867 1 2 867 868 0 1 868 869 0 3 869 870 1 3 870 871 0 3 871 872 1 1 872 873 0 1 873 874 0 3 874 875 1 2 875 876 1 3 876 877 0 3 877 878 0 3 878 879 0 3 879 880 1 1 880 881 1 2 881 882 0 3 882 883 0 3 883 884 0 2 884 885 0 3 885 886 0 3 886 887 0 2 887 888 1 1 888 889 0 3 889 890 1 1 890 891 0 3 Name Sex Age SibSp \0 Braund, Mr. Owen Harris male 22.0 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 2 Heikkinen, Miss. Laina female 26.0 0 3 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 4 Allen, Mr. William Henry male 35.0 0 5 Moran, Mr. James male NaN 0 6 McCarthy, Mr. Timothy J male 54.0 0 7 Palsson, Master. Gosta Leonard male 2.0 3 8 Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg) female 27.0 0 9 Nasser, Mrs. Nicholas (Adele Achem) female 14.0 1 10 Sandstrom, Miss. Marguerite Rut female 4.0 1 11 Bonnell, Miss. Elizabeth female 58.0 0 12 Saundercock, Mr. William Henry male 20.0 0 13 Andersson, Mr. Anders Johan male 39.0 1 14 Vestrom, Miss. Hulda Amanda Adolfina female 14.0 0 15 Hewlett, Mrs. (Mary D Kingcome) female 55.0 0 16 Rice, Master. Eugene male 2.0 4 17 Williams, Mr. Charles Eugene male NaN 0 18 Vander Planke, Mrs. Julius (Emelia Maria Vande... female 31.0 1 19 Masselmani, Mrs. Fatima female NaN 0 20 Fynney, Mr. Joseph J male 35.0 0 21 Beesley, Mr. Lawrence male 34.0 0 22 McGowan, Miss. Anna "Annie" female 15.0 0 23 Sloper, Mr. William Thompson male 28.0 0 24 Palsson, Miss. Torborg Danira female 8.0 3 25 Asplund, Mrs. Carl Oscar (Selma Augusta Emilia... female 38.0 1 26 Emir, Mr. Farred Chehab male NaN 0 27 Fortune, Mr. Charles Alexander male 19.0 3 28 O'Dwyer, Miss. Ellen "Nellie" female NaN 0 29 Todoroff, Mr. Lalio male NaN 0 .. ... ... ... ... 861 Giles, Mr. Frederick Edward male 21.0 1 862 Swift, Mrs. Frederick Joel (Margaret Welles Ba... female 48.0 0 863 Sage, Miss. Dorothy Edith "Dolly" female NaN 8 864 Gill, Mr. John William male 24.0 0 865 Bystrom, Mrs. (Karolina) female 42.0 0 866 Duran y More, Miss. Asuncion female 27.0 1 867 Roebling, Mr. Washington Augustus II male 31.0 0 868 van Melkebeke, Mr. Philemon male NaN 0 869 Johnson, Master. Harold Theodor male 4.0 1 870 Balkic, Mr. Cerin male 26.0 0 871 Beckwith, Mrs. Richard Leonard (Sallie Monypeny) female 47.0 1 872 Carlsson, Mr. Frans Olof male 33.0 0 873 Vander Cruyssen, Mr. Victor male 47.0 0 874 Abelson, Mrs. Samuel (Hannah Wizosky) female 28.0 1 875 Najib, Miss. Adele Kiamie "Jane" female 15.0 0 876 Gustafsson, Mr. Alfred Ossian male 20.0 0 877 Petroff, Mr. Nedelio male 19.0 0 878 Laleff, Mr. Kristo male NaN 0 879 Potter, Mrs. Thomas Jr (Lily Alexenia Wilson) female 56.0 0 880 Shelley, Mrs. William (Imanita Parrish Hall) female 25.0 0 881 Markun, Mr. Johann male 33.0 0 882 Dahlberg, Miss. Gerda Ulrika female 22.0 0 883 Banfield, Mr. Frederick James male 28.0 0 884 Sutehall, Mr. Henry Jr male 25.0 0 885 Rice, Mrs. William (Margaret Norton) female 39.0 0 886 Montvila, Rev. Juozas male 27.0 0 887 Graham, Miss. Margaret Edith female 19.0 0 888 Johnston, Miss. Catherine Helen "Carrie" female NaN 1 889 Behr, Mr. Karl Howell male 26.0 0 890 Dooley, Mr. Patrick male 32.0 0 Parch Ticket Fare Cabin Embarked 0 0 A/5 21171 7.2500 NaN S 1 0 PC 17599 71.2833 C85 C 2 0 STON/O2. 3101282 7.9250 NaN S 3 0 113803 53.1000 C123 S 4 0 373450 8.0500 NaN S 5 0 330877 8.4583 NaN Q 6 0 17463 51.8625 E46 S 7 1 349909 21.0750 NaN S 8 2 347742 11.1333 NaN S 9 0 237736 30.0708 NaN C 10 1 PP 9549 16.7000 G6 S 11 0 113783 26.5500 C103 S 12 0 A/5. 2151 8.0500 NaN S 13 5 347082 31.2750 NaN S 14 0 350406 7.8542 NaN S 15 0 248706 16.0000 NaN S 16 1 382652 29.1250 NaN Q 17 0 244373 13.0000 NaN S 18 0 345763 18.0000 NaN S 19 0 2649 7.2250 NaN C 20 0 239865 26.0000 NaN S 21 0 248698 13.0000 D56 S 22 0 330923 8.0292 NaN Q 23 0 113788 35.5000 A6 S 24 1 349909 21.0750 NaN S 25 5 347077 31.3875 NaN S 26 0 2631 7.2250 NaN C 27 2 19950 263.0000 C23 C25 C27 S 28 0 330959 7.8792 NaN Q 29 0 349216 7.8958 NaN S .. ... ... ... ... ... 861 0 28134 11.5000 NaN S 862 0 17466 25.9292 D17 S 863 2 CA. 2343 69.5500 NaN S 864 0 233866 13.0000 NaN S 865 0 236852 13.0000 NaN S 866 0 SC/PARIS 2149 13.8583 NaN C 867 0 PC 17590 50.4958 A24 S 868 0 345777 9.5000 NaN S 869 1 347742 11.1333 NaN S 870 0 349248 7.8958 NaN S 871 1 11751 52.5542 D35 S 872 0 695 5.0000 B51 B53 B55 S 873 0 345765 9.0000 NaN S 874 0 P/PP 3381 24.0000 NaN C 875 0 2667 7.2250 NaN C 876 0 7534 9.8458 NaN S 877 0 349212 7.8958 NaN S 878 0 349217 7.8958 NaN S 879 1 11767 83.1583 C50 C 880 1 230433 26.0000 NaN S 881 0 349257 7.8958 NaN S 882 0 7552 10.5167 NaN S 883 0 C.A./SOTON 34068 10.5000 NaN S 884 0 SOTON/OQ 392076 7.0500 NaN S 885 5 382652 29.1250 NaN Q 886 0 211536 13.0000 NaN S 887 0 112053 30.0000 B42 S 888 2 W./C. 6607 23.4500 NaN S 889 0 111369 30.0000 C148 C 890 0 370376 7.7500 NaN Q [891 rows x 12 columns]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fblog%2F2016%2F10%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
